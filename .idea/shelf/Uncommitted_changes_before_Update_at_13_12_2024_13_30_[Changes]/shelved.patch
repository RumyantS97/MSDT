Index: msdt-1/lab1_file1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/msdt-1/lab1_file1.py b/msdt-1/lab1_file1.py
new file mode 100644
--- /dev/null	(date 1734082212804)
+++ b/msdt-1/lab1_file1.py	(date 1734082212804)
@@ -0,0 +1,140 @@
+import random
+
+# Пузырьковая сортировка
+def bubble_sort (arr):
+    n = len(arr)
+    for i in range(n):
+        for j in range(0, n - i - 1):
+            if arr[j] > arr[j + 1]:
+                arr[j], arr[j + 1] = arr[j + 1], arr[j]
+    return arr
+
+# Сортировка перемешиванием
+def cocktail_shaker_sort(arr):
+    n=len(arr)
+    start = 0
+    end = n - 1
+    while start <= end:
+        swapped = False
+        for i in range(start, end):
+            if arr[i] > arr[i + 1]:
+                arr[i], arr[i + 1] = arr[i + 1], arr[i]
+                swapped = True
+        end -= 1
+        for i in range(end, start, -1):
+            if arr[i] < arr[i - 1]:
+                arr[i], arr[i - 1] = arr[i - 1], arr[i]
+                swapped = True
+        start += 1
+        if not swapped:
+            break
+    return arr
+
+# Сортировка вставками
+def insertion_sort(arr):
+    for i in range(1, len(arr)):
+        key = arr[i]
+        j = i - 1
+        while j >= 0 and key < arr[j]:
+            arr[j + 1] = arr[j]
+            j -= 1
+        arr[j + 1] = key
+    return arr
+
+# Быстрая сортировка
+def quick_sort(arr):
+    if len(arr) <= 1:
+        return arr
+    pivot = arr[len(arr) // 2]
+    left = [x for x in arr if x < pivot]
+    middle = [x for x in arr if x == pivot]
+    right = [x for x in arr if x > pivot]
+    return quick_sort(left) + middle + quick_sort(right)
+
+# Пирамидальная сортировка (Heap Sort)
+def heapify(arr,n,i):
+    largest = i
+    left = 2 * i + 1
+    right = 2 * i + 2
+
+    if left < n and arr[left] > arr[largest]:
+        largest = left
+
+    if right < n and arr[right] > arr[largest]:
+        largest = right
+
+    if largest != i:
+        arr[i], arr[largest] = arr[largest], arr[i]
+        heapify(arr, n, largest)
+
+def heap_sort(arr):
+    n = len(arr)
+    for i in range(n // 2 - 1, -1, -1):
+        heapify(arr, n, i)
+    for i in range(n - 1, 0, -1):
+        arr[i], arr[0] = arr[0], arr[i]
+        heapify(arr, i, 0)
+    return arr
+
+# Блочная сортировка (Bucket Sort)
+def bucket_sort(arr):
+    if len(arr) == 0:
+        return arr
+    bucket_count = len(arr)
+    max_val = max(arr)
+    min_val = min(arr)
+    bucket_size = (max_val - min_val) / bucket_count
+    buckets = [[] for _ in range(bucket_count)]
+
+    for num in arr:
+        index = int((num - min_val) / bucket_size)
+        if index == bucket_count:
+            index -= 1
+        buckets[index].append(num)
+
+    for bucket in buckets:
+        insertion_sort(bucket)
+
+    sorted_arr = []
+    for bucket in buckets:
+        sorted_arr.extend(bucket)
+    return sorted_arr
+
+def main():
+    size = int(input("Введите размер массива: "))
+    array = [ random.randint(0, 100) for _ in range(size)]
+    print("Сгенерированный массив:", array)
+    print("\nВыберите алгоритм сортировки:")
+    print("1. Пузырьковая сортировка")
+    print("2. Сортировка перемешиванием")
+    print("3. Сортировка вставками")
+    print("4. Быстрая сортировка")
+    print("5. Пирамидальная сортировка")
+    print("6. Блочная сортировка")
+    choice = input("Ваш выбор: ")
+
+    if choice == '1':
+        print("\nСортируем пузырьковой сортировкой...")
+        sorted_array = bubble_sort(array)
+    elif choice == '2':
+        print("\nСортируем сортировкой перемешиванием...")
+        sorted_array = cocktail_shaker_sort(array)
+    elif choice == '3':
+        print("\nСортируем сортировкой вставками...")
+        sorted_array = insertion_sort(array)
+    elif choice == '4':
+        print("\nСортируем быстрой сортировкой...")
+        sorted_array = quick_sort(array)
+    elif choice == '5':
+        print("\nСортируем пирамидальной сортировкой...")
+        sorted_array = heap_sort(array)
+    elif choice == '6':
+        print("\nСортируем блочной сортировкой...")
+        sorted_array = bucket_sort(array)
+    else:
+        print("Неверный выбор! Программа завершена.")
+        return
+    print("Отсортированный массив:", sorted_array)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: msdt-1/lab1_file2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/msdt-1/lab1_file2.py b/msdt-1/lab1_file2.py
new file mode 100644
--- /dev/null	(date 1734080606996)
+++ b/msdt-1/lab1_file2.py	(date 1734080606996)
@@ -0,0 +1,157 @@
+import heapq
+import random
+
+class HuffmanNode:
+    def __init__(self, char, freq):
+        self.char = char
+        self.freq = freq
+        self.left = None
+        self.right = None
+
+    def __lt__(self, other):
+        return self.freq < other.freq
+
+def build_huffman_tree(frequencies):
+    heap = [HuffmanNode(char, freq) for char, freq in frequencies.items()]
+    heapq.heapify(heap)
+    while len(heap) > 1:
+        Left = heapq.heappop(heap)
+        right = heapq.heappop(heap)
+        merged = HuffmanNode(None, Left.freq + right.freq)
+        merged.left = Left
+        merged.right = right
+        heapq.heappush(heap, merged)
+    return heap[0]
+
+def build_huffman_codes(tree, current_code="", codes=None):
+    if codes is None:
+        codes = {}
+
+    if tree.char is not None:
+        codes[tree.char] = current_code
+        return codes
+
+    if tree.left:
+        build_huffman_codes(tree.left, current_code + "0", codes)
+    if tree.right:
+        build_huffman_codes(tree.right, current_code + "1", codes)
+    return codes
+
+def huffman_encode(text, huffman_codes):
+    return ''.join(huffman_codes[char] for char in text)
+
+def huffman_decode(encoded_text, tree):
+    decoded_text = []
+    current = tree
+
+    for bit in encoded_text:
+        if bit == '0':
+            current = current.left
+        else:
+            current = current.right
+
+        if current.char is not None:
+            decoded_text.append(current.char)
+            current = tree
+    return ''.join(decoded_text)
+
+from collections import Counter
+
+def frequency_analysis(text):
+    return Counter(text)
+
+def naive_search(text, pattern):
+    n, m = len(text), len(pattern)
+    for i in range(n - m + 1):
+        if text[i:i + m] == pattern:
+            return i
+    return -1
+
+def kmp_search(text, pattern):
+    def build_prefix_table(pattern):
+        m = len(pattern)
+        lps = [0] * m
+        j = 0
+        for i in range(1, m):
+            if pattern[i] == pattern[j]:
+                j += 1
+                lps[i] = j
+            else:
+                if j != 0:
+                    j = lps[j - 1]
+                    i -= 1
+                else:
+                    lps[i] = 0
+        return lps
+
+    lps = build_prefix_table(pattern)
+    i, j = 0, 0
+    while i < len(text):
+        if pattern[j] == text[i]:
+            i += 1
+            j += 1
+        if j == len(pattern):
+            return i - j
+        elif i < len(text) and pattern[j] != text[i]:
+            if j != 0:
+                j = lps[j - 1]
+            else:
+                i += 1
+    return -1
+
+def find_palindromes(text):
+    palindromes = []
+    n = len(text)
+
+    def expand_around_center(left, right):
+        while left >= 0 and right < n and text[left] == text[right]:
+            palindromes.append(text[left:right + 1])
+            left -= 1
+            right += 1
+
+    for i in range(n):
+        expand_around_center(i, i)      # Odd-length palindromes
+        expand_around_center(i, i + 1)  # Even-length palindromes
+    return palindromes
+
+def main():
+    print("7. Наивный алгоритм и алгоритм Кнута-Морриса-Пратта для поиска подстроки")
+    print("8. Алгоритм поиска всех палиндромных подстрок")
+    print("9. Алгоритмы для частотного анализа и кодирования Хаффмана")
+    choice = input("Ваш выбор: ")
+
+    if choice == '1':
+        text = input("Введите текст: ")
+        pattern = input("Введите подстроку для поиска: ")
+        print("\nНаивный алгоритм:")
+        naive_result = naive_search(text, pattern)
+        print("Результат:", naive_result)
+        print("\nАлгоритм Кнута-Морриса-Пратта:")
+        kmp_result = kmp_search(text, pattern)
+        print("Результат:", kmp_result)
+    elif choice == '8':
+        text = input("Введите текст: ")
+        palindromes = find_palindromes(text)
+        print("\nНайденные палиндромные подстроки:", palindromes)
+    elif choice == '9':
+        text = input("Введите текст для анализа частоты символов: ")
+        frequencies = frequency_analysis(text)
+        print("\nЧастоты символов:", frequencies)
+
+        text = input("Введите текст для кодирования: ")
+        frequencies = frequency_analysis(text)
+        print("\nЧастоты символов:", frequencies)
+        huffman_tree = build_huffman_tree(frequencies)
+        huffman_codes = build_huffman_codes(huffman_tree)
+        print("\nКоды Хаффмана:", huffman_codes)
+        encoded_text = huffman_encode(text, huffman_codes)
+        print("\nЗакодированный текст:", encoded_text)
+        decoded_text = huffman_decode(encoded_text, huffman_tree)
+        print("\nДекодированный текст:", decoded_text)
+
+    else:
+        print("Неверный выбор! Программа завершена.")
+        return
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
Index: msdt-1/lab1_file3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/msdt-1/lab1_file3.py b/msdt-1/lab1_file3.py
new file mode 100644
--- /dev/null	(date 1734080748771)
+++ b/msdt-1/lab1_file3.py	(date 1734080748771)
@@ -0,0 +1,66 @@
+def Add(a, b):
+    return a + b
+
+def subtract(a, b):
+    return a - b
+
+def multiply(a, b):
+    return a * b
+
+def divide(a, b):
+    if b == 0:
+        return "Ошибка: деление на ноль невозможно."
+    return a / b
+
+def power(a, b):
+    return a ** b
+
+def modulus(a, b):
+    if b == 0:
+        return "Ошибка: деление на ноль невозможно."
+    return a % b
+
+def manual_calculator():
+    print("Добро пожаловать в ручной калькулятор!")
+    print("Выберите операцию:")
+    print("1: Сложение (+)")
+    print("2: Вычитание (-)")
+    print("3: Умножение (*)")
+    print("4: Деление (/)")
+    print("5: Возведение в степень (**)")
+    print("6: Остаток от деления (%)")
+    print("Введите 'exit', чтобы выйти.")
+
+    while True:
+        choice = input("\nВыберите операцию: ")
+        if choice.lower() == 'exit':
+            print("Выход из программы. До свидания!")
+            break
+
+        if choice not in ['1', '2', '3', '4', '5', '6']:
+            print("Ошибка: некорректный ввод. Попробуйте снова.")
+            continue
+
+        try:
+            num1 = float(input("Введите первое число: "))
+            num2 = float(input("Введите второе число: "))
+
+            if choice == '1':
+                print(f"Результат: {num1} + {num2} = {Add(num1, num2)}")
+            elif choice == '2':
+                print(f"Результат: {num1} - {num2} = {subtract(num1, num2)}")
+            elif choice == '3':
+                print(f"Результат: {num1} * {num2} = {multiply(num1, num2)}")
+            elif choice == '4':
+                print(f"Результат: {num1} / {num2} = {divide(num1, num2)}")
+            elif choice == '5':
+                print(f"Результат: {num1} ** {num2} = {power(num1, num2)}")
+            elif choice == '6':
+                print(f"Результат: {num1} % {num2} = {modulus(num1, num2)}")
+        except ValueError:
+            print("Ошибка: введите числовые значения.")
+        except Exception as e:
+            print(f"Неожиданная ошибка: {e}")
+
+# запуск программы
+manual_calculator()
