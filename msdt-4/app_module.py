from timeout_for_fractal_optimal_depth import calculate_optimal_depth
from structured_concurrency.structured_concurrency_test import get_image_list
from asyncio import run

async def main1():
    print(await calculate_optimal_depth(6, 100, -2.2, 1.2, -1.2, 1.2, 500, 500))

async def main2():
    print(len(await get_image_list()))

run(main2())

#Информация по асинхронности/корутинам
#1) Использовать когда необходимо реализовать параллельную обработку разных групп данных у объектов, например в UI реализовать анимации, или в игре запустить у игрока множество корутин, обрабатываюших игровой процесс
#2) Использовать для делегирования ответственности и параллельного исп. вычислительной мощности РАЗНЫХ устройств. Например отправить сразу несколько запросов на разные сервера, поскольку можно не делать их последовательно
#3) Использовать для параллельных вычислений. Например обрабатывать сразу 4 изображения.
#4) в отличие от многопоточности у корутин лучше устроен свой жизненный цикл, они образуют древовидную структуру и могут быть отменены, засчет чего ими легче управлять, есть принципы cooperative cancellation и structured concurrency, которые удобно помогают в работе. Однако есть несколько подводных камней, которые могут нарушить работу корутин.
#Корутины отменяются по факту засчет возниковения CancellationException, его можно обработать в finally, чтобы закрыть ресурсы и, если идет интеграция с Observer паттерном, отключить наблюдателей. но всегда нужно пробрасывать это исключение вверх, чтобы внешняя оболочка try catch рабочей корутины отловила Cancellation и постивила Job статус на cancelled, чтобы родителям не пришлось ждать ее. Так же если операция async, но выполняется долго, ее нельзя отменить. Решение - либо мини-проверки по ходу операции(неуниверсально), либо обертка через доп звено - корутину, которая просто ждет await эту корутину